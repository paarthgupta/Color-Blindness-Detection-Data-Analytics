# -*- coding: utf-8 -*-
#"""Untitled1.ipynb

#Automatically generated by Colaboratory.

#Original file is located at
#    https://colab.research.google.com/drive/105QoVdeDZbSv4YOPECOv3ZPRNU0Z1jhi
#"""

#from google.colab import drive
#drive.mount('/content/gdrive')

import sys
from bitarray import bitarray

import pandas as pd
from scipy import stats

import math
import matplotlib.pyplot as plt

import pickle
from bitarray import bitarray

import numpy as np

data = np.loadtxt('./../data/chrX_last_col.txt', dtype=str)


reference = np.loadtxt("./../data/chrX_map.txt", dtype=str)

sequence = np.loadtxt("./../data/chrX.fa", dtype=str)

#print("end")

qq = 149249757       # values given in readme file
ww = 149249868
ee = 149256127
rr = 149256423
tt = 149258412
yy = 149258580
uu = 149260048
ii = 149260213
oo = 149261768
pp = 149262007
aa = 149264290
ss = 149264400

#print("end")

dd = 149288166
ff = 149288277
gg = 149293258
hh = 149293554
jj = 149295542
kk = 149295710
ll = 149297178
zz = 149297343
xx = 149298898
cc = 149299137
vv = 149301420
bb = 149301530
#print("end")


def r_query(char, idx):                                 # code for finding rank query 
    rank = 0
    if idx == 0:
        return rank                           
    #if(char == 'G'):
    x=eval(char)
    y=eval(char+'_c')
    while (((idx - 1) % 100) != 0):
        idx = idx - 1
        if (x[idx] != 0):
            rank = rank + 1
    rank = rank + y[int((idx-1) / 100)]
    return rank

def mat_red(index, length):
    if index >= qq and index <= ww:               # checking whether the given index lies in sone range or not.
        return 1, 0
    elif index >= ee and index <= rr:
        return 1, 1
    elif index >= tt and index <= yy:
        return 1, 2
    elif index >= uu and index <= ii:
        return 1, 3
    elif index >= oo and index <= pp:
        return 1, 4
    elif index >= aa and index <= ss:
        return 1, 5
    else:
        return 0, -1
#print("end")
def mat_green(index, length):
    if index >= dd and index <= ff:
        return 1, 0
    elif index >= gg and index <= hh:
        return 1, 1
    elif index >= jj and index <= kk:
        return 1, 2
    elif index >= ll and index <= zz:
        return 1, 3
    elif index >= xx and index <= cc:
        return 1, 4
    elif index >= vv and index <= bb:
        return 1, 5
    else:
        return 0, -1
#print("end")

ms = ''.join(sequence[1:])
bwt_full = ''.join(data)
count=[]
for i in range(4):
    count.append(0)

l = len(bwt_full)
print("Total space for 4 arrays is 4n where n is equal to")
print(l)
G= bitarray(l)
G.setall(False)
#print("end")
A= bitarray(l)
A.setall(False)
#print("end")
C= bitarray(l)#print("end")
C.setall(False)
#print("end")
T= bitarray(l)
T.setall(False)
#print("end")
d = 100
count = l/100 + 1
G_c,A_c,C_c,T_c = [],[],[],[]            
g_c,c_c,a_c,t_c = 0,0,0,0
for i in range(len(bwt_full)):
    char = bwt_full[i]
    if (char == "A"):
        A[i] = True      # A is present on ith location
        a_c =a_c + 1
    elif (char == "C"):
        C[i] = True
        c_c =c_c + 1
    elif (char == "T"):
        T[i] = True #print("end")
        t_c += 1
    elif (char == "G"):
        G[i] = True
        g_c += 1
    if (i % d == 0):
        G_c.append(g_c)                                 # making those extra delta rank arrays 
        A_c.append(a_c)
        T_c.append(t_c)
        C_c.append(c_c)    #print("end")

a_count= a_c
g_count=g_c
c_count=c_c
t_count=t_c

first = 0
second = a_count
third = a_count + c_count
fourth = a_count + c_count + g_count

#print("end")
rem = [0, 0, 0, 0, 0, 0]
gem = [0, 0, 0, 0, 0, 0]
full = np.loadtxt('./../data/reads', dtype=str)
without_n = []
for line in full:
    if 'N' in line:
        new_line = line.replace('N', 'A')
        without_n.append(new_line)
    else:
        without_n.append(line)
#print("end")

def mat_ind(read):
    fgh = read[-1]
    if fgh == 'A':
        ert = 0
        dfg = second - 1
    elif fgh == 'C':
        ert = a_count
        dfg = third- 1
    elif fgh == 'G':
        ert = third
        dfg = fourth - 1
    elif fgh == 'T':
        ert = fourth
        dfg = fourth + t_count - 1
#print("end")
    for i in range(2, len(read)+1):
        char = read[-1*i]
        sttr = r_query(char, ert)
        etr = r_query(char, dfg)
        if sttr == etr:
            return None, None;
#print("end")
        if char == 'A':
            ert= first + sttr
            dfg= first + etr
        elif char == 'C':
            ert= second + sttr
            dfg= second + etr
        elif char == 'G':
            ert= third + sttr
            dfg= third + etr
        elif char == 'T':
            ert= fourth + sttr
            dfg= fourth + etr
 #print("end")
    return ert, dfg

#print("end")

                   # need to delete


def m_ref(si, ei):
    xcv = []
    for i in range(ei - si):
        xcv.append(int(reference[si+i])) #print("end")
    return xcv
lrs = len(ms)
def misref_seq(idx, read):
    mis_count = 0
    if lrs <= idx + len(read):
        return -1
    for i in range(len(read)):
        if(ms[idx+i] != read[i]):
            mis_count += 1
    return mis_count#print("end")

def gmii(read):
    rf = read[-1]
    if rf == 'A':
        bsi = 0
        bei = second - 1
    elif rf == 'C':
        bsi = second
        bei = third - 1 
    #print("end")
    elif rf == 'G':
        bsi = third
        bei = fourth - 1
    elif rf == 'T':
        bsi = fourth
        bei = fourth + t_count - 1
    #print("end")
    for i in range(2, len(read)+1):
        to = read[-1*i]
        strr = r_query(to, bsi)
        etr = r_query(to, bei)
        if strr == etr:
            return None, None;
        bsi = xcv(to, strr)
        bei = xcv(to, etr)
    return bsi, bei
#print("end")

def xcv(chaar, xdc):
    if chaar == 'A':
        return first + xdc
    elif chaar == 'C':
        return second + xdc
    elif chaar == 'G':
        return third + xdc
    elif chaar == 'T':
        return fourth + xdc

def abc(si, ei, rl):
    edcv = []
    for i in range(ei - si):
        edcv.append(int(reference[si+i]))
    red_e = []
    green_e = []
    for rtg in edcv:
        aas, qqa = mat_red(rtg, rl)
        aaw, qqs = mat_green(rtg, rl)
        if (aas == 1):
            red_e.append(qqa)
        if (aaw == 1):
            green_e.append(qqs)
    if len(red_e) > 0 and len(green_e) > 0:
        for nm in red_e:
            rem[nm] += 0.5
        for nm in green_e:
            gem[nm] += 0.5
    elif len(red_e) > 0:
        for nm in red_e:
            rem[nm] += 1
    elif len(green_e) > 0:
        for nm in green_e:
            gem[nm] += 1
    else:
        pass

#yuiu=0
for line in without_n:
    # print(yuiu)
    si, ei = gmii(line)
    if si is not None and ei is not None:
        abc(si, ei, len(line))



for read in without_n:
    rl = len(read)
    fpart = read[0 : int(rl/3)]
    spart = read[int(rl/3) : int(2*rl/3)]
    tpart = read[int(2*rl/3) : (rl)]
    fpbm, f_end = mat_ind(fpart)
    spbm, s_end = mat_ind(spart)
    tpbm, t_end = mat_ind(tpart)

    first_rm = []
    second_rm = []
    third_rm = []
    
    if fpbm is not None and f_end is not None:
        first_rm = m_ref(fpbm, f_end)
    
    if spbm is not None and s_end is not None:
        second_rm = m_ref(spbm, s_end)
    
    if tpbm is not None and t_end is not None:
        third_rm = m_ref(tpbm, t_end)
    len_fp = len(fpart)
    len_sp = len(spart)
   
    second_rm = [val - len_fp for val in second_rm]

    # for val in second_rm:
    #     second_rem.append(val - len_fp)
    third_rm = [val -len_fp - len_sp for val in third_rm]

    # for val in third_rm:
    #     third_rem.append(val -len_fp - len_sp)
    
    cm = set(first_rm) & set(second_rm) & set(third_rm)
    first_rem = set(first_rm).difference(cm)
    second_rem = set(second_rm).difference(cm)
    third_rem = set(third_rm).difference(cm)
    all_rem = list(first_rem.union(second_rem.union(third_rem))) 
    if(len(all_rem) > 0):
        cvb = []
        reqd_g = []
        for i in range(len(all_rem)):
            mis_count = misref_seq(all_rem[i], read)
            if mis_count > 0 and mis_count < 3:
                poi, rfv = mat_red(all_rem[i], rl)
                lkj, edc = mat_green(all_rem[i], rl)
                if (poi==True):
                    cvb.append(rfv)
                if (lkj==True):
                    reqd_g.append(edc)
        
        if len(cvb) > 0 and len(reqd_g) > 0:
            for enumber in cvb:
                rem[enumber] =rem[enumber]+ 0.5
            for enumber in reqd_g:
                gem[enumber] =gem[enumber]+ 0.5
        elif len(cvb) > 0:
            for enumber in cvb:
                rem[enumber] =rem[enumber]+ 1
        elif len(reqd_g) > 0:
            for enumber in reqd_g:
                gem[enumber] =gem[enumber]+ 1
        else:
            pass

print("Total Red exon count .........")
print(rem)
print("Total Grren exon count .......")
print(gem)

print("probability calculation is given in report for checking which config is more probable")





# for reference help taken grom hhttps://github.com/anirban-code-to-live/color-blindness-detection/


